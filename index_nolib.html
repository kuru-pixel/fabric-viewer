<!doctype html><html><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fabric Viewer (No external libs)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;font-family:system-ui}
  #ui{position:fixed;z-index:2;top:10px;left:10px;background:#0b0b0bcc;color:#fff;padding:12px;border-radius:10px}
  #ui label{display:block;font-size:12px;margin:6px 0 4px} #ui input[type="range"]{width:220px}
  #msg{position:fixed;z-index:2;bottom:10px;left:50%;transform:translateX(-50%);background:#0009;color:#fff;padding:6px 10px;border-radius:8px;font-size:12px}
  #footer{position:fixed;right:10px;bottom:10px;z-index:2;font-size:12px;background:#0b0b0bcc;color:#fff;padding:6px 10px;border-radius:8px}
  canvas#c{position:fixed;inset:0;width:100vw;height:100vh;display:block;background:#141414}
</style>
</head><body>
<div id="ui">
  <div style="font-weight:600;margin-bottom:6px">Fabric Viewer (No-CDN)</div>
  <label>生地画像アップ（JPG/PNG）<input id="file" type="file" accept="image/*"></label>
  <label>タイル倍率 <input id="repeat" type="range" min="1" max="12" step="0.5" value="3"> <span id="repv">3</span></label>
  <label>回転（度） <input id="rot" type="range" min="0" max="180" step="1" value="0"> <span id="rotv">0</span></label>
  <button id="resetCam">カメラリセット</button>
</div>
<div id="footer">ドラッグで回転 / ホイールでズーム / 右ドラッグで移動</div>
<div id="msg" hidden></div>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl',{antialias:true});
if(!gl){ alert('WebGLが無効です。ブラウザのハードウェアアクセラレーションを有効にしてください。'); }

function resize(){ const w=canvas.clientWidth,h=canvas.clientHeight;
  if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h; gl.viewport(0,0,w,h); }
}
window.addEventListener('resize', resize); resize();

const VSH = `
attribute vec3 aPos; attribute vec2 aUV; attribute vec3 aNormal;
uniform mat4 uProj, uView, uModel;
varying vec2 vUV; varying vec3 vN; varying vec3 vWPos;
void main(){
  vUV = aUV; vN = mat3(uModel)*aNormal;
  vec4 wpos = uModel * vec4(aPos,1.0); vWPos = wpos.xyz;
  gl_Position = uProj * uView * wpos;
}`;
const FSH = `
precision mediump float;
uniform sampler2D uTex; uniform vec2 uRepeat; uniform float uRot; 
uniform vec3 uEye; varying vec2 vUV; varying vec3 vN; varying vec3 vWPos;
mat2 rot(float r){ float c=cos(r), s=sin(r); return mat2(c,-s,s,c); }
void main(){
  vec2 uv = (rot(uRot)*(vUV-vec2(0.5)))+vec2(0.5); uv *= uRepeat;
  vec3 base = texture2D(uTex, uv).rgb;
  // 簡易ライティング
  vec3 N = normalize(vN);
  vec3 L = normalize(vec3(0.6,1.0,0.8));
  vec3 V = normalize(uEye - vWPos);
  float ndl = max(dot(N,L),0.0);
  vec3 color = base*(0.25 + 0.75*ndl);
  gl_FragColor = vec4(color,1.0);
}`;

function compile(type,src){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s); return s; }
function program(vs,fs){ const p=gl.createProgram(); gl.attachShader(p,compile(gl.VERTEX_SHADER,vs));
  gl.attachShader(p,compile(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p);
  if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw gl.getProgramInfoLog(p); return p; }
const prog = program(VSH,FSH); gl.useProgram(prog);

// 立方体ジオメトリ（位置/法線/UV）
const P=[-1,-1, 1, 1,-1, 1, 1, 1, 1, -1, 1, 1,  // +Z
         1,-1,-1, -1,-1,-1, -1, 1,-1, 1, 1,-1,  // -Z
        -1,-1,-1, -1,-1, 1, -1, 1, 1, -1, 1,-1, // -X
         1,-1, 1, 1,-1,-1, 1, 1,-1, 1, 1, 1,   // +X
        -1, 1, 1, 1, 1, 1, 1, 1,-1, -1, 1,-1,  // +Y
        -1,-1,-1, 1,-1,-1, 1,-1, 1, -1,-1, 1]; // -Y
const N=[0,0,1, 0,0,1, 0,0,1, 0,0,1,
         0,0,-1,0,0,-1,0,0,-1,0,0,-1,
        -1,0,0,-1,0,0,-1,0,0,-1,0,0,
         1,0,0,1,0,0,1,0,0,1,0,0,
         0,1,0,0,1,0,0,1,0,0,1,0,
         0,-1,0,0,-1,0,0,-1,0,0,-1,0];
const T=[0,0, 1,0, 1,1, 0,1,
         0,0, 1,0, 1,1, 0,1,
         0,0, 1,0, 1,1, 0,1,
         0,0, 1,0, 1,1, 0,1,
         0,0, 1,0, 1,1, 0,1,
         0,0, 1,0, 1,1, 0,1];
const idx=[0,1,2, 0,2,3, 4,5,6, 4,6,7, 8,9,10, 8,10,11, 12,13,14, 12,14,15, 16,17,18, 16,18,19, 20,21,22, 20,22,23];

function buf(data,attrib,name,size){ const b=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,b);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(data),gl.STATIC_DRAW);
  const loc=gl.getAttribLocation(prog,name); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,size,gl.FLOAT,false,0,0); }

buf(P,gl.ARRAY_BUFFER,'aPos',3);
buf(N,gl.ARRAY_BUFFER,'aNormal',3);
buf(T,gl.ARRAY_BUFFER,'aUV',2);
const ib=gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ib);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(idx),gl.STATIC_DRAW);

// 行列ユーティリティ
function mat4(){ return new Float32Array(16); }
function ident(m){ m.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); return m; }
function persp(out,fovy,aspect,near,far){
  const f=1/Math.tan(fovy/2), nf=1/(near-far);
  out.set([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0]); return out;
}
function lookAt(out,eye,center,up){
  const x0=eye[0]-center[0], x1=eye[1]-center[1], x2=eye[2]-center[2];
  let len = Math.hypot(x0,x1,x2); const z=[x0/len,x1/len,x2/len];
  const ux=up[1]*z[2]-up[2]*z[1], uy=up[2]*z[0]-up[0]*z[2], uz=up[0]*z[1]-up[1]*z[0];
  len=Math.hypot(ux,uy,uz); const x=[ux/len,uy/len,uz/len];
  const y=[z[1]*x[2]-z[2]*x[1], z[2]*x[0]-z[0]*x[2], z[0]*x[1]-z[1]*x[0]];
  out.set([x[0],y[0],z[0],0, x[1],y[1],z[1],0, x[2],y[2],z[2],0,
           -(x[0]*eye[0]+x[1]*eye[1]+x[2]*eye[2]),
           -(y[0]*eye[0]+y[1]*eye[1]+y[2]*eye[2]),
           -(z[0]*eye[0]+z[1]*eye[1]+z[2]*eye[2]),1]);
  return out;
}
function rotateY(out,a){ const c=Math.cos(a), s=Math.sin(a); out[0]= c; out[2]= s; out[5]=1; out[8]=-s; out[10]=c; out[15]=1; out[1]=out[3]=out[4]=out[6]=out[7]=out[9]=out[11]=out[12]=out[13]=out[14]=0; return out;}

const uProj=gl.getUniformLocation(prog,'uProj');
const uView=gl.getUniformLocation(prog,'uView');
const uModel=gl.getUniformLocation(prog,'uModel');
const uTex=gl.getUniformLocation(prog,'uTex');
const uRepeat=gl.getUniformLocation(prog,'uRepeat');
const uRot=gl.getUniformLocation(prog,'uRot');
const uEye=gl.getUniformLocation(prog,'uEye');

gl.uniform1i(uTex,0);

let eye=[0,0,3], yaw=0, pitch=0, dist=3;
function updateCam(){ eye=[dist*Math.sin(yaw)*Math.cos(pitch), dist*Math.sin(pitch), dist*Math.cos(yaw)*Math.cos(pitch)];
  const V=mat4(); lookAt(V,eye,[0,0,0],[0,1,0]); gl.uniform3f(uEye,eye[0],eye[1],eye[2]); gl.uniformMatrix4fv(uView,false,V);
  const P=mat4(); persp(P,45*Math.PI/180, canvas.width/canvas.height, 0.1, 100); gl.uniformMatrix4fv(uProj,false,P);
}
updateCam();

let tex=null, repeat=3, rotDeg=0;
function pot(n){ let p=1; while(p<n) p<<=1; return p; }
function setTextureFromImage(img){
  // 非POTをPOTに変換（REPEATを使うため）
  let w=img.width,h=img.height; const W=pot(w), H=pot(h);
  const cv=document.createElement('canvas'); cv.width=W; cv.height=H;
  const cx=cv.getContext('2d'); cx.drawImage(img,0,0,W,H);
  const t=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,t);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,cv);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR_MIPMAP_LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
  gl.generateMipmap(gl.TEXTURE_2D);
  tex=t;
}

document.getElementById('file').addEventListener('change', e=>{
  const f=e.target.files&&e.target.files[0]; if(!f) return;
  const img=new Image(); img.onload=()=>{ setTextureFromImage(img); showMsg('生地テクスチャを適用しました'); };
  img.src = URL.createObjectURL(f);
});
const rep=document.getElementById('repeat'), rot=document.getElementById('rot'), repv=document.getElementById('repv'), rotv=document.getElementById('rotv');
rep.addEventListener('input', ()=>{ repeat=parseFloat(rep.value); repv.textContent=rep.value; });
rot.addEventListener('input', ()=>{ rotDeg=parseFloat(rot.value); rotv.textContent=rot.value; });
document.getElementById('resetCam').addEventListener('click', ()=>{ yaw=0; pitch=0; dist=3; updateCam(); });

let dragging=false, lastX=0,lastY=0, right=false;
canvas.addEventListener('mousedown',e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; right=(e.button===2); });
window.addEventListener('mouseup',()=>dragging=false);
window.addEventListener('mousemove',e=>{
  if(!dragging) return; const dx=(e.clientX-lastX)/200, dy=(e.clientY-lastY)/200; lastX=e.clientX; lastY=e.clientY;
  if(right){ dist=Math.min(8, Math.max(1, dist*(1+dy))); } else { yaw+=dx; pitch=Math.max(-1.2,Math.min(1.2,pitch+dy)); }
  updateCam();
});
canvas.addEventListener('contextmenu',e=>e.preventDefault());
canvas.addEventListener('wheel',e=>{ dist=Math.min(8,Math.max(1,dist*(1+e.deltaY*0.001))); updateCam(); });

function showMsg(s){ const el=document.getElementById('msg'); el.textContent=s; el.hidden=false; clearTimeout(showMsg.t); showMsg.t=setTimeout(()=>el.hidden=true,2200); }

function loop(t){
  resize(); gl.clearColor(0.08,0.08,0.08,1); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT); gl.enable(gl.DEPTH_TEST);
  const M=mat4(); rotateY(M,t*0.001); gl.uniformMatrix4fv(uModel,false,M);
  gl.activeTexture(gl.TEXTURE0); if(tex) gl.bindTexture(gl.TEXTURE_2D,tex);
  gl.uniform2f(uRepeat, repeat, repeat); gl.uniform1f(uRot, rotDeg*Math.PI/180.0);
  gl.drawElements(gl.TRIANGLES, idx.length, gl.UNSIGNED_SHORT, 0);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body></html>
