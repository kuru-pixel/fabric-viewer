<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fabric Viewer (Safe)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial}
    #ui{position:fixed;z-index:2;top:10px;left:10px;background:#0b0b0bcc;color:#fff;padding:12px 12px 8px;border-radius:10px;backdrop-filter:blur(6px)}
    #ui h1{font-size:14px;margin:0 0 8px 0;font-weight:600;opacity:.9}
    #ui label{display:block;font-size:12px;margin:6px 0 4px}
    #ui input[type="file"]{font-size:12px}
    #ui input[type="range"]{width:220px}
    #ui .row{display:flex;gap:8px;align-items:center}
    #ui small{opacity:.8}
    #msg{position:fixed;z-index:2;bottom:10px;left:50%;transform:translateX(-50%);background:#0009;color:#fff;padding:8px 12px;border-radius:8px;font-size:12px}
    #footer{position:fixed;right:10px;bottom:10px;z-index:2;font-size:12px;background:#0b0b0bcc;color:#fff;padding:6px 10px;border-radius:8px}
    button{border:1px solid #ffffff44;background:#ffffff10;color:#fff;border-radius:8px;padding:6px 10px;cursor:pointer}
    button:hover{background:#ffffff18}
    /* ←これが重要：キャンバスを全画面に */
    canvas#c{position:fixed;inset:0;width:100vw;height:100vh;display:block}
  </style>
</head>
<body>
  <div id="ui">
    <h1>Fabric Viewer</h1>
    <label>生地画像アップ（JPG/PNG）</label>
    <input type="file" id="file" accept="image/*">
    <div class="row">
      <label style="min-width:78px;">タイル倍率</label>
      <input type="range" id="repeat" min="1" max="12" step="0.5" value="3">
      <span id="repv" style="width:24px;display:inline-block;text-align:right">3</span>
    </div>
    <div class="row">
      <label style="min-width:78px;">回転（度）</label>
      <input type="range" id="rot" min="0" max="180" step="1" value="0">
      <span id="rotv" style="width:24px;display:inline-block;text-align:right">0</span>
    </div>
    <div class="row" style="margin-top:6px;">
      <button id="resetCam">カメラリセット</button>
      <small id="matinfo"></small>
    </div>
    <div style="margin-top:6px;"><small>※ `assets/garment.glb` を置くと服モデルで表示。無い間はキューブ。</small></div>
  </div>
  <div id="footer">ドラッグで回転 / ホイールでズーム / 右ドラッグで移動</div>
  <div id="msg" hidden></div>
  <canvas id="c"></canvas>

  <!-- UMD 版（import不要）。もしこのCDNが合わなければ unpkg に差し替え可 -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  // ---- 設定 ----
  const SHOULD_APPLY_TO_ALL = true;       // ← 確実に貼れるようまずは true
  const GLB_PATH = './assets/garment.glb';

  // ---- 基本セットアップ ----
  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  if (renderer.outputColorSpace !== undefined) renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x141414);

  const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 100);
  camera.position.set(0, 1.6, 3.2);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  const hemi = new THREE.HemisphereLight(0xffffff, 0x223, 1.0);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(2,2,4);
  scene.add(dir);

  // ---- モデル読み込み or プレースホルダー ----
  let model, targetMats = [];
  const loader = new THREE.GLTFLoader();
  loader.load(GLB_PATH, (glb)=>{
    model = glb.scene;
    scene.add(model);
    analyzeMaterials(model);
    fitCameraToObject(model);
    showMsg('garment.glb を読み込みました');
  }, undefined, ()=>{
    // エラー → プレースホルダー
    const geo = new THREE.BoxGeometry(1,1.2,0.5);
    const mat = new THREE.MeshStandardMaterial({color:0x999999, metalness:0.1, roughness:0.7});
    const cube = new THREE.Mesh(geo, mat); cube.name = 'placeholder';
    scene.add(cube);
    targetMats = [cube.material];
    updateMatInfo();
    showMsg('assets/garment.glb が無いのでキューブを表示しています');
  });

  function analyzeMaterials(root){
    const mats = new Set();
    root.traverse(o=>{
      if(o.isMesh && o.material){
        if (Array.isArray(o.material)) o.material.forEach(m => mats.add(m));
        else mats.add(o.material);
      }
    });
    targetMats = Array.from(mats).filter(m => (m.name||'').startsWith('fabric_') && m.isMeshStandardMaterial);
    if (!targetMats.length && SHOULD_APPLY_TO_ALL){
      targetMats = Array.from(mats).filter(m => m.isMeshStandardMaterial);
    }
    updateMatInfo();
  }
  function updateMatInfo(){
    document.getElementById('matinfo').textContent = `適用対象: ${targetMats.length} material(s)`;
  }
  function fitCameraToObject(obj){
    const box = new THREE.Box3().setFromObject(obj);
    const size = box.getSize(new THREE.Vector3()).length();
    const center = box.getCenter(new THREE.Vector3());
    controls.target.copy(center);
    const dist = size * 0.6 / Math.tan((Math.PI * camera.fov) / 360);
    camera.position.copy(center.clone().add(new THREE.Vector3(0, size*0.1, dist)));
    camera.near = size / 100; camera.far = size * 10; camera.updateProjectionMatrix();
    controls.update();
  }

  // ---- 生地アップロード／タイル／回転 ----
  const texLoader = new THREE.TextureLoader();
  const repeatEl = document.getElementById('repeat');
  const rotEl = document.getElementById('rot');
  const repv = document.getElementById('repv');
  const rotv = document.getElementById('rotv');

  function applyTexture(url){
    const t = texLoader.load(url, ()=>{
      if (t.colorSpace !== undefined) t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.anisotropy = renderer.capabilities.getMaxAnisotropy();
      updateTiling();
      showMsg('生地テクスチャを適用しました');
    });
    targetMats.forEach(m=>{
      if (m.isMeshStandardMaterial){
        m.map = t; m.needsUpdate = true;
        if (typeof m.metalness === 'number') m.metalness = Math.min(m.metalness, 0.15);
        if (typeof m.roughness === 'number') m.roughness = Math.max(m.roughness, 0.6);
      }
    });
  }
  function updateTiling(){
    repv.textContent = repeatEl.value;
    rotv.textContent = rotEl.value;
    targetMats.forEach(m=>{
      if (m.map){
        m.map.repeat.set(parseFloat(repeatEl.value), parseFloat(repeatEl.value));
        m.map.rotation = parseFloat(rotEl.value) * Math.PI/180;
        m.map.center.set(0.5,0.5);
        m.map.needsUpdate = true;
      }
    });
  }
  document.getElementById('file').addEventListener('change', e=>{
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    applyTexture(URL.createObjectURL(f));
  });
  repeatEl.addEventListener('input', updateTiling);
  rotEl.addEventListener('input', updateTiling);
  document.getElementById('resetCam').addEventListener('click', ()=>{
    if (model) fitCameraToObject(model); else { camera.position.set(0,1.2,3); controls.target.set(0,0,0); controls.update(); }
  });

  // ---- ループ ----
  function resize(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    if (canvas.width!==w || canvas.height!==h){
      renderer.setSize(w, h, false);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    }
  }
  function animate(){
    resize(); controls.update(); renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();

  // ---- メッセージ ----
  let msgTimer;
  function showMsg(s){
    const el = document.getElementById('msg');
    el.textContent = s; el.hidden = false;
    clearTimeout(msgTimer); msgTimer = setTimeout(()=>{ el.hidden = true; }, 3000);
  }
  </script>
</body>
</html>
