<!doctype html><html><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fabric Viewer</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;font-family:system-ui}
  canvas#c{position:fixed;inset:0;width:100vw;height:100vh;display:block}

  /* ==== 左パネル（開閉スライド） ==== */
  #uiWrap{position:fixed;z-index:5;top:10px;left:10px;display:flex;align-items:flex-start;transition:transform .25s ease}
  #ui{background:#0b0b0bcc;color:#fff;padding:12px;border-radius:10px;max-width:420px}
  #ui label{display:block;font-size:12px;margin:6px 0 4px}
  #ui input[type="range"]{width:220px}
  .btnRow{display:flex;gap:6px;align-items:center;margin-bottom:6px;flex-wrap:wrap}
  .mini{margin-left:6px;font-size:12px;padding:2px 6px}

  #uiToggle{margin-left:6px;align-self:center;cursor:pointer;border:none;outline:none;width:32px;height:56px;border-radius:8px;
    background:#e23;color:#fff;font-size:20px;line-height:56px;text-align:center;user-select:none;box-shadow:0 2px 8px #0006}
  #uiWrap.collapsed{transform:translateX(calc(-100% + 32px))}

  .block{margin-top:8px;padding:8px;border:1px solid #ffffff22;border-radius:8px}
  .block h4{margin:0 0 4px 0;font-size:13px}

  #footer{position:fixed;right:10px;bottom:10px;z-index:4;font-size:12px;background:#0b0b0bcc;color:#fff;padding:6px 10px;border-radius:8px}
  #msg{position:fixed;z-index:6;bottom:10px;left:50%;transform:translateX(-50%);background:#0009;color:#fff;padding:6px 10px;border-radius:8px;font-size:12px}

  /* ==== クリック時の吹き出し ==== */
  #bubble{
    position:fixed; z-index:7; display:none; transform:translate(-50%,-115%); pointer-events:auto;
    background:#111e; color:#fff; backdrop-filter: blur(4px);
    border:1px solid #fff3; border-radius:10px; padding:6px 8px; box-shadow:0 4px 16px #0008;
  }
  #bubble .row{display:flex; gap:6px; align-items:center; flex-wrap:wrap; max-width:320px}
  .chip{
    width:56px;height:56px;border-radius:8px;border:1px solid #fff5;background:#222 center/cover no-repeat;cursor:pointer;
    display:flex;align-items:center;justify-content:center;font-weight:700;letter-spacing:.5px;
  }
  .chip.none{background:#222}
  .chip:hover{outline:2px solid #fff9}
</style>
</head><body>

<!-- ===== 左パネル ===== -->
<div id="uiWrap">
  <div id="ui">
    <div style="font-weight:600;margin-bottom:6px">Fabric Viewer</div>

    <div class="btnRow">
      <button id="resetCam">カメラリセット</button>
      <button id="resetAll" title="倍率/回転を初期化・割り当てを全て『なし』・見た目を白に戻す">リセット</button>
      <button id="shot" title="今の画面をPNG保存">スクショPNG</button>
      <small id="matinfo" style="margin-left:auto;"></small>
    </div>

    <!-- A -->
    <div class="block">
      <h4>生地A</h4>
      <div class="btnRow">
        <label style="margin:0"><input id="texA" type="file" accept="image/*"></label>
        <button id="clearA" class="mini" type="button">クリアA</button>
      </div>
      <label>タイル倍率A <input id="repeatA" type="range" min="1" max="12" step="0.5" value="3"> <span id="repvA">3</span></label>
      <label>回転A（度） <input id="rotA" type="range" min="0" max="180" step="1" value="0"> <span id="rotvA">0</span></label>
    </div>

    <!-- B -->
    <div class="block">
      <h4>生地B</h4>
      <div class="btnRow">
        <label style="margin:0"><input id="texB" type="file" accept="image/*"></label>
        <button id="clearB" class="mini" type="button">クリアB</button>
      </div>
      <label>タイル倍率B <input id="repeatB" type="range" min="1" max="12" step="0.5" value="3"> <span id="repvB">3</span></label>
      <label>回転B（度） <input id="rotB" type="range" min="0" max="180" step="1" value="0"> <span id="rotvB">0</span></label>
    </div>

    <!-- C -->
    <div class="block">
      <h4>生地C</h4>
      <div class="btnRow">
        <label style="margin:0"><input id="texC" type="file" accept="image/*"></label>
        <button id="clearC" class="mini" type="button">クリアC</button>
      </div>
      <label>タイル倍率C <input id="repeatC" type="range" min="1" max="12" step="0.5" value="3"> <span id="repvC">3</span></label>
      <label>回転C（度） <input id="rotC" type="range" min="0" max="180" step="1" value="0"> <span id="rotvC">0</span></label>
    </div>

    <!-- D -->
    <div class="block">
      <h4>生地D</h4>
      <div class="btnRow">
        <label style="margin:0"><input id="texD" type="file" accept="image/*"></label>
        <button id="clearD" class="mini" type="button">クリアD</button>
      </div>
      <label>タイル倍率D <input id="repeatD" type="range" min="1" max="12" step="0.5" value="3"> <span id="repvD">3</span></label>
      <label>回転D（度） <input id="rotD" type="range" min="0" max="180" step="1" value="0"> <span id="rotvD">0</span></label>
    </div>

    <!-- E -->
    <div class="block">
      <h4>生地E</h4>
      <div class="btnRow">
        <label style="margin:0"><input id="texE" type="file" accept="image/*"></label>
        <button id="clearE" class="mini" type="button">クリアE</button>
      </div>
      <label>タイル倍率E <input id="repeatE" type="range" min="1" max="12" step="0.5" value="3"> <span id="repvE">3</span></label>
      <label>回転E（度） <input id="rotE" type="range" min="0" max="180" step="1" value="0"> <span id="rotvE">0</span></label>
    </div>

    <div style="margin-top:6px;"><small>※ <code>assets/garment.glb</code> が無い間はキューブ表示 / パーツは3D上をクリックして選択</small></div>
  </div>

  <button id="uiToggle" aria-label="toggle panel">‹</button>
</div>

<!-- クリック位置に出る吹き出し（A〜E + なし） -->
<div id="bubble">
  <div style="font-size:12px;margin-bottom:4px">生地を割り当て</div>
  <div class="row">
    <button class="chip" id="pickA">A</button>
    <button class="chip" id="pickB">B</button>
    <button class="chip" id="pickC">C</button>
    <button class="chip" id="pickD">D</button>
    <button class="chip" id="pickE">E</button>
    <button class="chip none" id="pickNone">なし</button>
  </div>
</div>

<div id="footer">ドラッグで回転 / ホイールでズーム / 右ドラッグで移動</div>
<div id="msg" hidden></div>
<canvas id="c"></canvas>

<script src="./assets/threejs/three.min.js"></script>
<script src="./assets/threejs/GLTFLoader.js"></script>
<script src="./assets/threejs/OrbitControls.js"></script>

<script>
/* ========= 基本 ========= */
const GLB_PATH = './assets/garment.glb';
const $ = (id)=>document.getElementById(id);
const SLOTS = ['A','B','C','D','E']; // ★ スロット拡張

/* three.js */
const canvas = $('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
if (renderer.outputColorSpace !== undefined) renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x141414);
const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 100); camera.position.set(0,1.6,3.2);
const controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true;
scene.add(new THREE.HemisphereLight(0xffffff,0x223,1.0));
const dir = new THREE.DirectionalLight(0xffffff,1.0); dir.position.set(2,2,4); scene.add(dir);

/* モデル */
let model, targetMats = [];
const loader = new THREE.GLTFLoader();
loader.load(GLB_PATH, (glb)=>{
  model=glb.scene; scene.add(model); analyze(model); fit(model); msg('garment.glb を読み込みました');
  // 自動UVスケール推定（初回のみ）
  applyAutoUVScaleIfFirst(model);
  // 保存してあれば割り当て復元
  loadAssignFromStorage(); applyAssignments();
}, undefined, ()=>{
  const g=new THREE.BoxGeometry(1,1.2,0.5);
  const m=new THREE.MeshStandardMaterial({color:0x999999,metalness:0.1,roughness:0.7});
  const cube=new THREE.Mesh(g,m); scene.add(cube);
  targetMats=[cube.material]; updateMatInfo();
  applyAutoUVScaleIfFirst(cube);
  loadAssignFromStorage(); applyAssignments();
  msg('assets/garment.glb が無いのでキューブ表示');
});

/* ===== ユーティリティ ===== */
function isSupportedMat(m){
  return !!m && (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial || m.isMeshLambertMaterial || m.isMeshPhongMaterial || m.isMeshBasicMaterial);
}

/* マテリアル抽出（使用数カウントつき） */
const materialUseCount = new Map();  // material.uuid -> 参照数
function analyze(root){
  const mats=new Set();
  materialUseCount.clear();
  root.traverse(o=>{
    if(o.isMesh && o.material){
      if(Array.isArray(o.material)){
        o.material.forEach(m=>{
          if(m){ mats.add(m); materialUseCount.set(m.uuid,(materialUseCount.get(m.uuid)||0)+1); }
        });
      }else{
        const m=o.material;
        if(m){ mats.add(m); materialUseCount.set(m.uuid,(materialUseCount.get(m.uuid)||0)+1); }
      }
    }
  });
  targetMats = Array.from(mats).filter(isSupportedMat);
  updateMatInfo();
}
function updateMatInfo(){ $('matinfo').textContent = `適用対象: ${targetMats.length} material(s)`; }

/* カメラ */
function fit(obj){
  const box=new THREE.Box3().setFromObject(obj),
        size=box.getSize(new THREE.Vector3()).length(),
        center=box.getCenter(new THREE.Vector3());
  controls.target.copy(center);
  const dist=size*0.6/Math.tan((Math.PI*camera.fov)/360);
  camera.position.copy(center.clone().add(new THREE.Vector3(0,size*0.1,dist)));
  camera.near=size/100; camera.far=size*10; camera.updateProjectionMatrix(); controls.update();
}

/* ===== A〜E の状態 & 永続化 ===== */
const texLoader = new THREE.TextureLoader();
const state = {
  A:{ tex:null, url:'', repeat:3, rotDeg:0, repEl:$('repeatA'), rotEl:$('rotA'), repv:$('repvA'), rotv:$('rotvA'), fileEl:$('texA') },
  B:{ tex:null, url:'', repeat:3, rotDeg:0, repEl:$('repeatB'), rotEl:$('rotB'), repv:$('repvB'), rotv:$('rotvB'), fileEl:$('texB') },
  C:{ tex:null, url:'', repeat:3, rotDeg:0, repEl:$('repeatC'), rotEl:$('rotC'), repv:$('repvC'), rotv:$('rotvC'), fileEl:$('texC') },
  D:{ tex:null, url:'', repeat:3, rotDeg:0, repEl:$('repeatD'), rotEl:$('rotD'), repv:$('repvD'), rotv:$('rotvD'), fileEl:$('texD') },
  E:{ tex:null, url:'', repeat:3, rotDeg:0, repEl:$('repeatE'), rotEl:$('rotE'), repv:$('repvE'), rotv:$('rotvE'), fileEl:$('texE') },
};
const assign = {}; // material.uuid -> 'A'|'B'|'C'|'D'|'E'|'—'

const LS_KEYS = {
  sliders: 'fv_sliders_v1',   // {A:{repeat,rotDeg}, ...}
  assign : 'fv_assign_v1',    // {materialUUID:'A'|'B'|'C'|'D'|'E'|'—'}
  ui     : 'uiCollapsed'
};

function saveSlidersToStorage(){
  const data = {};
  SLOTS.forEach(k=>{ data[k] = {repeat: state[k].repeat, rotDeg: state[k].rotDeg}; });
  try{ localStorage.setItem(LS_KEYS.sliders, JSON.stringify(data)); }catch(e){}
}
function loadSlidersFromStorage(){
  try{
    const raw = localStorage.getItem(LS_KEYS.sliders);
    if(!raw) return false;
    const data = JSON.parse(raw);
    let applied = false;
    SLOTS.forEach(k=>{
      if(data[k]){
        const rep = Number(data[k].repeat); const rot = Number(data[k].rotDeg);
        if(Number.isFinite(rep)){ state[k].repeat = rep; state[k].repEl.value = rep; state[k].repv.textContent = rep; applied = true; }
        if(Number.isFinite(rot)){ state[k].rotDeg = rot; state[k].rotEl.value = rot; state[k].rotv.textContent = rot; applied = true; }
      }
    });
    return applied;
  }catch(e){ return false; }
}
function saveAssignToStorage(){
  try{ localStorage.setItem(LS_KEYS.assign, JSON.stringify(assign)); }catch(e){}
}
function loadAssignFromStorage(){
  try{
    const raw = localStorage.getItem(LS_KEYS.assign);
    if(!raw) return;
    const obj = JSON.parse(raw);
    Object.keys(obj).forEach(k=>{ assign[k] = obj[k]; });
  }catch(e){}
}

/* 自動UVスケール推定（初回のみ＝スライダー保存がまだ無い時） */
function applyAutoUVScaleIfFirst(rootObj){
  const had = localStorage.getItem(LS_KEYS.sliders);
  if(had) return; // 既にユーザ設定あり
  const box = new THREE.Box3().setFromObject(rootObj);
  const size = box.getSize(new THREE.Vector3());
  // ヒューリスティック：衣服の平均的な横×縦スケールから「1mあたりの目視タイル数 ≒ 2」を想定
  const L = Math.sqrt(size.x * size.y);               // 代表長さ（横×縦の幾何平均）
  let r = L * 2.0;                                    // 1mあたり2タイル換算
  r = Math.max(1, Math.min(12, Math.round(r*2)/2));   // 0.5刻みで 1〜12 にクランプ
  SLOTS.forEach(k=>{
    state[k].repeat = r;
    state[k].repEl.value = r;
    state[k].repv.textContent = r;
  });
  saveSlidersToStorage();
}

/* テクスチャ前処理＆適用 */
function prepTexture(t){
  if(!t) return;
  if (t.colorSpace!==undefined) t.colorSpace=THREE.SRGBColorSpace;
  t.wrapS=t.wrapT=THREE.RepeatWrapping;
  t.anisotropy=renderer.capabilities.getMaxAnisotropy();
}
function applyParamsToTexture(key){
  const s = state[key]; const t = s.tex; if(!t) return;
  s.repv.textContent = s.repeat; s.rotv.textContent = s.rotDeg;
  t.repeat.set(parseFloat(s.repeat), parseFloat(s.repeat));
  t.rotation = parseFloat(s.rotDeg) * Math.PI/180;
  t.center.set(0.5,0.5); t.needsUpdate = true;
  targetMats.forEach(m=>{ if(m.map===t) m.needsUpdate=true; });
}
function applyAssignments(){
  targetMats.forEach(m=>{
    const key = assign[m.uuid]; let tex = (key && state[key]) ? state[key].tex : null;
    if(isSupportedMat(m)){
      if(!tex || key==='—'){ m.map = null; if(m.color) m.color.set(0xffffff); }
      else { m.map = tex; }
      m.needsUpdate = true;
      if(typeof m.metalness==='number') m.metalness=Math.min(m.metalness,0.15);
      if(typeof m.roughness==='number') m.roughness=Math.max(m.roughness,0.6);
    }
  });
  SLOTS.forEach(applyParamsToTexture);
  saveAssignToStorage(); // ← 割当変更の度に保存
}

/* UI: カメラ / 画像読込 / スクショ */
$('resetCam').addEventListener('click', ()=>{
  if(model) fit(model);
  else { camera.position.set(0,1.2,3); controls.target.set(0,0,0); controls.update(); }
});
$('shot').addEventListener('click', ()=>{
  // 一旦レンダリングを最新にしてから保存
  renderer.render(scene, camera);
  const a = document.createElement('a');
  a.download = `fabric-viewer_${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
  a.href = renderer.domElement.toDataURL('image/png');
  a.click();
});

function loadTexFor(key, file){
  state[key].url = URL.createObjectURL(file);
  state[key].tex = texLoader.load(state[key].url, ()=>{
    prepTexture(state[key].tex); applyParamsToTexture(key); applyAssignments();
    updateBubblePreviews(); msg(`生地${key}を読み込みました`);
  });
}
SLOTS.forEach(k=>{
  $('tex'+k).addEventListener('change', e=>{ const f=e.target.files?.[0]; if(f) loadTexFor(k,f); });
});

/* クリア（画像のみ外す） */
function clearTexture(key){
  const s = state[key];
  s.tex = null; s.url=''; s.fileEl.value = '';
  updateBubblePreviews();
  applyAssignments();
  msg(`生地${key}をクリアしました`);
}
SLOTS.forEach(k=>{
  $('clear'+k).addEventListener('click', ()=>clearTexture(k));
});

/* スライダー：値→状態→テクスチャに反映（保存つき） */
SLOTS.forEach(k=>{
  state[k].repEl.addEventListener('input', ()=>{
    state[k].repeat = Number(state[k].repEl.value);
    applyParamsToTexture(k);
    saveSlidersToStorage();
  });
  state[k].rotEl.addEventListener('input', ()=>{
    state[k].rotDeg = Number(state[k].rotEl.value);
    applyParamsToTexture(k);
    saveSlidersToStorage();
  });
});

/* 初期：スライダー保存があれば復元（テクスチャはユーザ再選択が必要） */
loadSlidersFromStorage();

/* ===== クリックでパーツ選択 → 吹き出し ===== */
const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let pick = null;               // 現在選択中の Mesh
let overlay = null;            // 赤ハイライト用
let pickMatIndex = null;       // クリック面の materialIndex
const bubble = $('bubble');
const chipEls = {
  A:$('pickA'), B:$('pickB'), C:$('pickC'), D:$('pickD'), E:$('pickE'), None:$('pickNone')
};

function updateBubblePreviews(){
  SLOTS.forEach(k=>{
    const el = chipEls[k];
    if(!el) return;
    el.style.backgroundImage = state[k].url ? `url(${state[k].url})` : 'none';
    el.textContent = state[k].url ? '' : k;
  });
}
updateBubblePreviews();

function showHighlight(mesh){
  hideHighlight();
  if(!mesh || !mesh.geometry) return;
  const mat = new THREE.MeshBasicMaterial({
    color:0xff6b81, transparent:true, opacity:0.35, depthTest:false, depthWrite:false
  });
  overlay = new THREE.Mesh(mesh.geometry, mat);
  overlay.renderOrder = 9999;
  mesh.add(overlay); // ローカル子に付けるとトランスフォーム追従
}
function hideHighlight(){
  if(overlay && overlay.parent){ overlay.parent.remove(overlay); }
  overlay = null;
}
function hideBubble(){ bubble.style.display='none'; }

function setBubbleScreenPos(world){
  const p = world.clone().project(camera);
  const x = (p.x * .5 + .5) * canvas.clientWidth;
  const y = ( -p.y * .5 + .5) * canvas.clientHeight;
  bubble.style.left = `${x}px`;
  bubble.style.top  = `${y}px`;
}

function onCanvasClick(ev){
  const r = canvas.getBoundingClientRect();
  mouse.x = ((ev.clientX - r.left)/r.width) * 2 - 1;
  mouse.y = -((ev.clientY - r.top)/r.height) * 2 + 1;
  ray.setFromCamera(mouse, camera);

  const targets = [];
  scene.traverse(o=>{ if(o.isMesh) targets.push(o); });
  const hits = ray.intersectObjects(targets, true);
  const hit = hits.find(h => h.object && (h.object.material));

  if(!hit){ pick=null; pickMatIndex=null; hideHighlight(); hideBubble(); return; }

  pick = hit.object;
  pickMatIndex = (Array.isArray(pick.material) && hit.face && typeof hit.face.materialIndex==='number')
    ? hit.face.materialIndex : null;
  showHighlight(pick);

  const wp = hit.point.clone().add(new THREE.Vector3(0, 0.02, 0));
  setBubbleScreenPos(wp);
  bubble.style.display='block';

  controls.update();
}
canvas.addEventListener('pointerdown', onCanvasClick);

/* 同じMaterialを他メッシュと共有していたら、その場でクローンして専有化 */
function ensureUniqueMaterialOnMesh(mesh, idx){
  if(Array.isArray(mesh.material)){
    const old = mesh.material[idx];
    if(!old) return null;
    const count = materialUseCount.get(old.uuid)||0;
    if(count > 1){
      const clone = old.clone();
      mesh.material[idx] = clone;
      materialUseCount.set(old.uuid, count-1);
      materialUseCount.set(clone.uuid, 1);
      if(isSupportedMat(clone)) targetMats.push(clone);
      return clone;
    }
    return old;
  }else{
    const old = mesh.material;
    if(!old) return null;
    const count = materialUseCount.get(old.uuid)||0;
    if(count > 1){
      const clone = old.clone();
      mesh.material = clone;
      materialUseCount.set(old.uuid, count-1);
      materialUseCount.set(clone.uuid, 1);
      if(isSupportedMat(clone)) targetMats.push(clone);
      return clone;
    }
    return old;
  }
}

/* 吹き出しボタン → 割り当て（クリック面のサブマテリアル “だけ”） */
function assignToSelected(key){
  if(!pick || !pick.material) return;

  let mat = null;
  if(Array.isArray(pick.material)){
    const idx = (pickMatIndex!=null) ? pickMatIndex : 0;
    mat = ensureUniqueMaterialOnMesh(pick, idx);
  }else{
    mat = ensureUniqueMaterialOnMesh(pick, 0);
  }
  if(!mat) return;

  assign[mat.uuid] = key;   // ← このマテリアルだけ記録（'—'で解除）
  applyAssignments();
}
chipEls.A.onclick   = ()=>assignToSelected('A');
chipEls.B.onclick   = ()=>assignToSelected('B');
chipEls.C.onclick   = ()=>assignToSelected('C');
chipEls.D.onclick   = ()=>assignToSelected('D');
chipEls.E.onclick   = ()=>assignToSelected('E');
chipEls.None.onclick= ()=>assignToSelected('—');

/* パネル開閉（保存つき） */
const uiWrap = $('uiWrap'), uiToggle = $('uiToggle');
function setCollapsed(v){
  uiWrap.classList.toggle('collapsed', v);
  uiToggle.textContent = v ? '›' : '‹';
  localStorage.setItem(LS_KEYS.ui, v ? '1' : '0');
}
uiToggle.addEventListener('click', ()=> setCollapsed(!uiWrap.classList.contains('collapsed')));
setCollapsed(localStorage.getItem(LS_KEYS.ui)==='1');

/* ループ */
function resize(){ const w=canvas.clientWidth, h=canvas.clientHeight;
  if(canvas.width!==w||canvas.height!==h){ renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); } }
function loop(){
  resize(); controls.update(); renderer.render(scene,camera);
  if(pick && bubble.style.display!=='none'){
    const center = new THREE.Box3().setFromObject(pick).getCenter(new THREE.Vector3());
    setBubbleScreenPos(center);
  }
  requestAnimationFrame(loop);
} loop();

/* メッセージ */
let t; function msg(s){ const el=$('msg'); el.textContent=s; el.hidden=false; clearTimeout(t); t=setTimeout(()=>el.hidden=true,2500); }
</script>
</body></html>
