<!doctype html><html><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fabric Viewer (Local libs)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;font-family:system-ui}
  #ui{position:fixed;z-index:2;top:10px;left:10px;background:#0b0b0bcc;color:#fff;padding:12px;border-radius:10px;max-width:380px}
  #ui label{display:block;font-size:12px;margin:6px 0 4px}
  #ui input[type="range"]{width:220px}
  #msg{position:fixed;z-index:2;bottom:10px;left:50%;transform:translateX(-50%);background:#0009;color:#fff;padding:6px 10px;border-radius:8px;font-size:12px}
  #footer{position:fixed;right:10px;bottom:10px;z-index:2;font-size:12px;background:#0b0b0bcc;color:#fff;padding:6px 10px;border-radius:8px}
  canvas#c{position:fixed;inset:0;width:100vw;height:100vh;display:block}
  /* パーツ割り当てリスト */
  #matList > div{display:flex;gap:8px;align-items:center;margin:4px 0}
  #matList .name{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:12px}
  #matList select{background:#223;color:#fff;border:1px solid #445;border-radius:6px;padding:3px 6px}
  /* A/B/Cブロック */
  .block{margin-top:8px;padding:8px;border:1px solid #ffffff22;border-radius:8px}
  .block h4{margin:0 0 4px 0;font-size:13px}
</style>
</head><body>
<div id="ui">
  <div style="font-weight:600;margin-bottom:6px">Fabric Viewer</div>

  <button id="resetCam" style="margin-bottom:4px;">カメラリセット</button>
  <small id="matinfo" style="margin-left:6px;"></small>

  <!-- 生地 A -->
  <div class="block">
    <h4>生地A</h4>
    <label><input id="texA" type="file" accept="image/*"></label>
    <label>タイル倍率A <input id="repeatA" type="range" min="1" max="12" step="0.5" value="3"> <span id="repvA">3</span></label>
    <label>回転A（度） <input id="rotA" type="range" min="0" max="180" step="1" value="0"> <span id="rotvA">0</span></label>
  </div>

  <!-- 生地 B -->
  <div class="block">
    <h4>生地B</h4>
    <label><input id="texB" type="file" accept="image/*"></label>
    <label>タイル倍率B <input id="repeatB" type="range" min="1" max="12" step="0.5" value="3"> <span id="repvB">3</span></label>
    <label>回転B（度） <input id="rotB" type="range" min="0" max="180" step="1" value="0"> <span id="rotvB">0</span></label>
  </div>

  <!-- 生地 C -->
  <div class="block">
    <h4>生地C</h4>
    <label><input id="texC" type="file" accept="image/*"></label>
    <label>タイル倍率C <input id="repeatC" type="range" min="1" max="12" step="0.5" value="3"> <span id="repvC">3</span></label>
    <label>回転C（度） <input id="rotC" type="range" min="0" max="180" step="1" value="0"> <span id="rotvC">0</span></label>
  </div>

  <details style="margin-top:8px;" open>
    <summary>パーツ割り当て（A/B/C）</summary>
    <div id="matList" style="max-height:180px;overflow:auto;margin-top:6px;"></div>
    <small>ヒント：マテリアル名が <code>fabric_a*</code> / <code>fabric_b*</code> / <code>fabric_c*</code> なら初期値で自動割り当てされます。</small>
  </details>

  <div style="margin-top:6px;"><small>※ <code>assets/garment.glb</code> が無い間はキューブ表示</small></div>
</div>

<div id="footer">ドラッグで回転 / ホイールでズーム / 右ドラッグで移動</div>
<div id="msg" hidden></div>
<canvas id="c"></canvas>

<script src="./assets/threejs/three.min.js"></script>
<script src="./assets/threejs/GLTFLoader.js"></script>
<script src="./assets/threejs/OrbitControls.js"></script>

<script>
/* ===== 基本設定 ===== */
const GLB_PATH = './assets/garment.glb';

/* ===== three.js 初期化 ===== */
const canvas = document.querySelector('#c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
if (renderer.outputColorSpace !== undefined) renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x141414);
const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 100); camera.position.set(0,1.6,3.2);
const controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true;
scene.add(new THREE.HemisphereLight(0xffffff,0x223,1.0));
const dir = new THREE.DirectionalLight(0xffffff,1.0); dir.position.set(2,2,4); scene.add(dir);

/* ===== モデル読込 ===== */
let model;
let targetMats = [];
const loader = new THREE.GLTFLoader();
loader.load(GLB_PATH, (glb)=>{
  model=glb.scene; scene.add(model); analyze(model);
  forceWhiteBase();          // ★ 追加：初期表示は真っ白
  fit(model); msg('garment.glb を読み込みました');
}, undefined, ()=>{
  const g=new THREE.BoxGeometry(1,1.2,0.5);
  // ★ 白いキューブに変更
  const m=new THREE.MeshStandardMaterial({color:0xffffff,metalness:0.0,roughness:0.9});
  const cube=new THREE.Mesh(g,m); scene.add(cube);
  targetMats=[cube.material]; updateMatInfo(); buildMatList();
  msg('assets/garment.glb が無いのでキューブ表示');
});

/* ===== マテリアル抽出 ===== */
function analyze(root){
  const mats=new Set();
  root.traverse(o=>{
    if(o.isMesh && o.material){
      Array.isArray(o.material)?o.material.forEach(m=>mats.add(m)):mats.add(o.material);
    }
  });
  targetMats = Array.from(mats).filter(m =>
    (m && (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial || m.isMeshLambertMaterial || m.isMeshPhongMaterial))
  );
  updateMatInfo();
  buildMatList();
}
function updateMatInfo(){
  document.getElementById('matinfo').textContent = `適用対象: ${targetMats.length} material(s)`;
}

/* ===== 初期状態を真っ白にする ===== */
function forceWhiteBase(){
  const matsFabric = targetMats.filter(m => (m.name||'').toLowerCase().startsWith('fabric'));
  const mats = matsFabric.length ? matsFabric : targetMats;
  mats.forEach(m=>{
    if(!m) return;
    if('map' in m) m.map = null;        // 画像解除
    if(m.color) m.color.set(0xffffff);  // 白
    if(typeof m.metalness==='number') m.metalness = 0.0;
    if(typeof m.roughness==='number') m.roughness = 0.9;
    m.needsUpdate = true;
  });
}

/* ===== カメラ合わせ ===== */
function fit(obj){
  const box=new THREE.Box3().setFromObject(obj),
        size=box.getSize(new THREE.Vector3()).length(),
        center=box.getCenter(new THREE.Vector3());
  controls.target.copy(center);
  const dist=size*0.6/Math.tan((Math.PI*camera.fov)/360);
  camera.position.copy(center.clone().add(new THREE.Vector3(0,size*0.1,dist)));
  camera.near=size/100; camera.far=size*10; camera.updateProjectionMatrix(); controls.update();
}

/* ===== テクスチャ状態（A/B/C ごと） ===== */
const texLoader = new THREE.TextureLoader();
const state = {
  A:{ tex:null, repeat:3, rotDeg:0, repEl:repeatA, rotEl:rotA, repv:repvA, rotv:rotvA },
  B:{ tex:null, repeat:3, rotDeg:0, repEl:repeatB, rotEl:rotB, repv:repvB, rotv:rotvB },
  C:{ tex:null, repeat:3, rotDeg:0, repEl:repeatC, rotEl:rotC, repv:repvC, rotv:rotvC },
};
const assign = {}; // material.uuid -> 'A'|'B'|'C'|'—'

function prepTexture(t){
  if(!t) return;
  if (t.colorSpace!==undefined) t.colorSpace=THREE.SRGBColorSpace;
  t.wrapS=t.wrapT=THREE.RepeatWrapping;
  t.anisotropy=renderer.capabilities.getMaxAnisotropy();
}

/* key: 'A'|'B'|'C' のパラメータをテクスチャに反映 */
function applyParamsToTexture(key){
  const s = state[key];
  const t = s.tex;
  if(!t) return;
  s.repv.textContent = s.repeat;
  s.rotv.textContent = s.rotDeg;
  t.repeat.set(parseFloat(s.repeat), parseFloat(s.repeat));
  t.rotation = parseFloat(s.rotDeg) * Math.PI/180;
  t.center.set(0.5,0.5);
  t.needsUpdate = true;
  targetMats.forEach(m=>{ if(m.map===t) m.needsUpdate=true; });
}

/* パーツ割り当てを反映（なしは真っ白に） */
function applyAssignments(){
  targetMats.forEach(m=>{
    const key = assign[m.uuid]; // 'A'|'B'|'C'|'—'
    let tex = (key && state[key]) ? state[key].tex : null;

    if(m && (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial || m.isMeshLambertMaterial || m.isMeshPhongMaterial)){
      if(!tex || key==='—'){
        m.map = null;
        if(m.color) m.color.set(0xffffff);
      } else {
        m.map = tex;
      }
      m.needsUpdate = true;
      if(typeof m.metalness==='number') m.metalness=Math.min(m.metalness,0.15);
      if(typeof m.roughness==='number') m.roughness=Math.max(m.roughness,0.6);
    }
  });
  ['A','B','C'].forEach(applyParamsToTexture);
}

/* パーツ割り当て UI を構築 */
function buildMatList(){
  const box = document.getElementById('matList');
  if(!box) return;
  box.innerHTML='';

  targetMats.forEach(m=>{
    if(!(m.uuid in assign)){
      const n = (m.name||'').toLowerCase();
      if(n.startsWith('fabric_a') || n.includes('_a_')) assign[m.uuid] = 'A';
      else if(n.startsWith('fabric_b') || n.includes('_b_')) assign[m.uuid] = 'B';
      else if(n.startsWith('fabric_c') || n.includes('_c_')) assign[m.uuid] = 'C';
      else assign[m.uuid] = '—';
    }

    const row  = document.createElement('div');
    const name = document.createElement('span');
    name.className='name';
    name.textContent = m.name || '(unnamed)';

    const sel = document.createElement('select');
    [['—','なし'],['A','A'],['B','B'],['C','C']].forEach(([v,t])=>{
      const o=document.createElement('option'); o.value=v; o.textContent=t; sel.appendChild(o);
    });
    sel.value = assign[m.uuid];
    sel.onchange = ()=>{ assign[m.uuid]=sel.value; applyAssignments(); };

    row.appendChild(name); row.appendChild(sel);
    box.appendChild(row);
  });
}

/* ===== UI イベント ===== */
document.getElementById('resetCam').addEventListener('click', ()=>{
  if(model) fit(model);
  else { camera.position.set(0,1.2,3); controls.target.set(0,0,0); controls.update(); }
});

/* 画像読込 */
texA.addEventListener('change', e=>{
  const f=e.target.files&&e.target.files[0]; if(!f) return;
  state.A.tex = texLoader.load(URL.createObjectURL(f), ()=>{
    prepTexture(state.A.tex); applyParamsToTexture('A'); applyAssignments(); msg('生地Aを読み込みました');
  });
});
texB.addEventListener('change', e=>{
  const f=e.target.files&&e.target.files[0]; if(!f) return;
  state.B.tex = texLoader.load(URL.createObjectURL(f), ()=>{
    prepTexture(state.B.tex); applyParamsToTexture('B'); applyAssignments(); msg('生地Bを読み込みました');
  });
});
texC.addEventListener('change', e=>{
  const f=e.target.files&&e.target.files[0]; if(!f) return;
  state.C.tex = texLoader.load(URL.createObjectURL(f), ()=>{
    prepTexture(state.C.tex); applyParamsToTexture('C'); applyAssignments(); msg('生地Cを読み込みました');
  });
});

/* スライダー（A/B/C個別） */
repeatA.addEventListener('input', ()=>{ state.A.repeat=repeatA.value; applyParamsToTexture('A'); });
rotA.addEventListener('input',    ()=>{ state.A.rotDeg=rotA.value;   applyParamsToTexture('A'); });

repeatB.addEventListener('input', ()=>{ state.B.repeat=repeatB.value; applyParamsToTexture('B'); });
rotB.addEventListener('input',    ()=>{ state.B.rotDeg=rotB.value;   applyParamsToTexture('B'); });

repeatC.addEventListener('input', ()=>{ state.C.repeat=repeatC.value; applyParamsToTexture('C'); });
rotC.addEventListener('input',    ()=>{ state.C.rotDeg=rotC.value;   applyParamsToTexture('C'); });

/* ===== ループ ===== */
function resize(){ const w=canvas.clientWidth, h=canvas.clientHeight; if(canvas.width!==w||canvas.height!==h){ renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); } }
function loop(){ resize(); controls.update(); renderer.render(scene,camera); requestAnimationFrame(loop); } loop();

/* ===== メッセージ ===== */
let t; function msg(s){ const el=document.getElementById('msg'); el.textContent=s; el.hidden=false; clearTimeout(t); t=setTimeout(()=>el.hidden=true,2500); }
</script>
</body></html>
