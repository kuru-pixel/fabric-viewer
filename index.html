<!doctype html><html><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fabric Viewer (Local libs)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;font-family:system-ui}
  canvas#c{position:fixed;inset:0;width:100vw;height:100vh;display:block}

  /* ==== UI（開閉スライド対応） ==== */
  #uiWrap{position:fixed;z-index:2;top:10px;left:10px;display:flex;align-items:flex-start;transition:transform .25s ease}
  #ui{background:#0b0b0bcc;color:#fff;padding:12px;border-radius:10px;max-width:380px}
  #ui label{display:block;font-size:12px;margin:6px 0 4px}
  #ui input[type="range"]{width:220px}
  .btnRow{display:flex;gap:6px;align-items:center;margin-bottom:6px}
  .mini{margin-left:6px;font-size:12px;padding:2px 6px}

  #uiToggle{margin-left:6px;align-self:center;cursor:pointer;border:none;outline:none;
    width:32px;height:56px;border-radius:8px;background:#e23;color:#fff;
    font-size:20px;line-height:56px;text-align:center;user-select:none;box-shadow:0 2px 8px #0006}
  #uiWrap.collapsed{transform:translateX(calc(-100% + 32px))}

  /* パーツリスト（クリック→吹き出し） */
  #matList > div{display:flex;gap:8px;align-items:center;margin:4px 0;padding:3px 6px;border-radius:6px;cursor:pointer}
  #matList > div:hover{background:#ffffff10}
  #matList .name{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:12px}
  .tag{font-size:11px;padding:1px 6px;border-radius:999px;background:#223;border:1px solid #445;color:#fff}

  .block{margin-top:8px;padding:8px;border:1px solid #ffffff22;border-radius:8px}
  .block h4{margin:0 0 4px 0;font-size:13px}

  #footer{position:fixed;right:10px;bottom:10px;z-index:2;font-size:12px;background:#0b0b0bcc;color:#fff;padding:6px 10px;border-radius:8px}
  #msg{position:fixed;z-index:2;bottom:10px;left:50%;transform:translateX(-50%);background:#0009;color:#fff;padding:6px 10px;border-radius:8px;font-size:12px}

  /* 吹き出し（A/B/C/なし） */
  #picker{position:fixed;z-index:5;background:#0b0b0bcc;border:1px solid #ffffff33;color:#fff;border-radius:10px;padding:8px;display:none;box-shadow:0 6px 24px #0008;max-width:280px}
  #picker h5{margin:0 0 6px 0;font-size:12px;opacity:.9}
  #picker .row{display:flex;gap:8px}
  #picker button{position:relative;border:1px solid #445;background:#223;color:#fff;border-radius:8px;cursor:pointer;width:72px;height:72px;display:flex;align-items:center;justify-content:center;overflow:hidden}
  #picker button.active{outline:2px solid #ff6b6b}
  #picker button img{max-width:100%;max-height:100%;display:none;border-radius:6px}
  #picker button .label{position:absolute;left:6px;bottom:6px;background:#0009;padding:0 6px;border-radius:4px;font-size:11px}
</style>
</head><body>

<div id="uiWrap">
  <div id="ui">
    <div style="font-weight:600;margin-bottom:6px">Fabric Viewer</div>

    <div class="btnRow">
      <button id="resetCam">カメラリセット</button>
      <button id="resetAll" title="倍率/回転を初期化・割り当てを全て『なし』・見た目を白に戻す">リセット</button>
      <small id="matinfo" style="margin-left:auto;"></small>
    </div>

    <!-- A -->
    <div class="block">
      <h4>生地A</h4>
      <div class="btnRow">
        <label style="margin:0"><input id="texA" type="file" accept="image/*"></label>
        <button id="clearA" class="mini" type="button">クリアA</button>
      </div>
      <label>タイル倍率A <input id="repeatA" type="range" min="1" max="12" step="0.5" value="3"> <span id="repvA">3</span></label>
      <label>回転A（度） <input id="rotA" type="range" min="0" max="180" step="1" value="0"> <span id="rotvA">0</span></label>
    </div>

    <!-- B -->
    <div class="block">
      <h4>生地B</h4>
      <div class="btnRow">
        <label style="margin:0"><input id="texB" type="file" accept="image/*"></label>
        <button id="clearB" class="mini" type="button">クリアB</button>
      </div>
      <label>タイル倍率B <input id="repeatB" type="range" min="1" max="12" step="0.5" value="3"> <span id="repvB">3</span></label>
      <label>回転B（度） <input id="rotB" type="range" min="0" max="180" step="1" value="0"> <span id="rotvB">0</span></label>
    </div>

    <!-- C -->
    <div class="block">
      <h4>生地C</h4>
      <div class="btnRow">
        <label style="margin:0"><input id="texC" type="file" accept="image/*"></label>
        <button id="clearC" class="mini" type="button">クリアC</button>
      </div>
      <label>タイル倍率C <input id="repeatC" type="range" min="1" max="12" step="0.5" value="3"> <span id="repvC">3</span></label>
      <label>回転C（度） <input id="rotC" type="range" min="0" max="180" step="1" value="0"> <span id="rotvC">0</span></label>
    </div>

    <details style="margin-top:8px;" open>
      <summary>パーツ（クリックで生地選択）</summary>
      <div id="matList" style="max-height:220px;overflow:auto;margin-top:6px;"></div>
      <small>ヒント：パーツをクリック → 吹き出しで A/B/C/なし を選んでください。</small>
    </details>

    <div style="margin-top:6px;"><small>※ <code>assets/garment.glb</code> が無い間はキューブ表示</small></div>
  </div>

  <button id="uiToggle" aria-label="toggle panel">‹</button>
</div>

<!-- A/B/C を選ぶ吹き出し -->
<div id="picker">
  <h5 id="pickerTitle">パーツに割り当て</h5>
  <div class="row">
    <button data-slot="A"><img><span class="label">A</span></button>
    <button data-slot="B"><img><span class="label">B</span></button>
    <button data-slot="C"><img><span class="label">C</span></button>
    <button data-slot="—"><span class="label">なし</span></button>
  </div>
</div>

<div id="footer">ドラッグで回転 / ホイールでズーム / 右ドラッグで移動</div>
<div id="msg" hidden></div>
<canvas id="c"></canvas>

<script src="./assets/threejs/three.min.js"></script>
<script src="./assets/threejs/GLTFLoader.js"></script>
<script src="./assets/threejs/OrbitControls.js"></script>

<script>
/* ========= 基本 ========= */
const GLB_PATH = './assets/garment.glb';
const $ = (id)=>document.getElementById(id);

/* three.js */
const canvas = $('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
if (renderer.outputColorSpace !== undefined) renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x141414);
const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 100); camera.position.set(0,1.6,3.2);
const controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true;
scene.add(new THREE.HemisphereLight(0xffffff,0x223,1.0));
const dir = new THREE.DirectionalLight(0xffffff,1.0); dir.position.set(2,2,4); scene.add(dir);

/* モデル */
let model, targetMats = [];
const loader = new THREE.GLTFLoader();
loader.load(GLB_PATH, (glb)=>{
  model=glb.scene; scene.add(model); analyze(model); fit(model); msg('garment.glb を読み込みました');
}, undefined, ()=>{
  const g=new THREE.BoxGeometry(1,1.2,0.5);
  const m=new THREE.MeshStandardMaterial({color:0x999999,metalness:0.1,roughness:0.7});
  const cube=new THREE.Mesh(g,m); scene.add(cube);
  targetMats=[cube.material]; updateMatInfo(); buildMatList();
  msg('assets/garment.glb が無いのでキューブ表示');
});

/* パーツ名の見やすい表示（必要に応じて拡張） */
function niceName(str=''){
  const s = str.toLowerCase();
  const dict = { 's_133_2524': '右肩','s_133_2524b':'左肩','s_132_2505':'右身頃','s_132_2505b':'左身頃','s_131_2485':'袖・リブ','default button':'ボタン類' };
  for (const k in dict){ if(s.includes(k)) return dict[k]; }
  if (s.startsWith('fabric_a')) return '（タグ）fabric_A';
  if (s.startsWith('fabric_b')) return '（タグ）fabric_B';
  if (s.startsWith('fabric_c')) return '（タグ）fabric_C';
  return str || '(unnamed)';
}

/* マテリアル抽出 */
function analyze(root){
  const mats=new Set();
  root.traverse(o=>{ if(o.isMesh && o.material){ Array.isArray(o.material)?o.material.forEach(m=>mats.add(m)):mats.add(o.material); }});
  targetMats = Array.from(mats).filter(m => (m && (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial || m.isMeshLambertMaterial || m.isMeshPhongMaterial)));
  updateMatInfo(); buildMatList();
}
function updateMatInfo(){ $('matinfo').textContent = `適用対象: ${targetMats.length} material(s)`; }

/* カメラ */
function fit(obj){
  const box=new THREE.Box3().setFromObject(obj), size=box.getSize(new THREE.Vector3()).length(), center=box.getCenter(new THREE.Vector3());
  controls.target.copy(center);
  const dist=size*0.6/Math.tan((Math.PI*camera.fov)/360);
  camera.position.copy(center.clone().add(new THREE.Vector3(0,size*0.1,dist)));
  camera.near=size/100; camera.far=size*10; camera.updateProjectionMatrix(); controls.update();
}

/* A/B/C の状態 */
const texLoader = new THREE.TextureLoader();
const state = {
  A:{ tex:null, repeat:3, rotDeg:0, repEl:$('repeatA'), rotEl:$('rotA'), repv:$('repvA'), rotv:$('rotvA'), fileEl:$('texA') },
  B:{ tex:null, repeat:3, rotDeg:0, repEl:$('repeatB'), rotEl:$('rotB'), repv:$('repvB'), rotv:$('rotvB'), fileEl:$('texB') },
  C:{ tex:null, repeat:3, rotDeg:0, repEl:$('repeatC'), rotEl:$('rotC'), repv:$('repvC'), rotv:$('rotvC'), fileEl:$('texC') },
};
const assign = {}; // material.uuid -> 'A'|'B'|'C'|'—'

function prepTexture(t){
  if(!t) return;
  if (t.colorSpace!==undefined) t.colorSpace=THREE.SRGBColorSpace;
  t.wrapS=t.wrapT=THREE.RepeatWrapping;
  t.anisotropy=renderer.capabilities.getMaxAnisotropy();
}

/* 倍率・回転をテクスチャへ反映 */
function applyParamsToTexture(key){
  const s = state[key]; const t = s.tex; if(!t) return;
  s.repv.textContent = s.repeat; s.rotv.textContent = s.rotDeg;
  t.repeat.set(parseFloat(s.repeat), parseFloat(s.repeat));
  t.rotation = parseFloat(s.rotDeg) * Math.PI/180; t.center.set(0.5,0.5); t.needsUpdate = true;
  targetMats.forEach(m=>{ if(m.map===t) m.needsUpdate=true; });
}

/* 割り当て適用（なし→真っ白） */
function applyAssignments(){
  targetMats.forEach(m=>{
    const key = assign[m.uuid]; let tex = (key && state[key]) ? state[key].tex : null;
    if(m && (m.isMeshStandardMaterial || m.isMeshPhysicalMaterial || m.isMeshLambertMaterial || m.isMeshPhongMaterial)){
      if(!tex || key==='—'){ m.map = null; if(m.color) m.color.set(0xffffff); }
      else { m.map = tex; }
      m.needsUpdate = true;
      if(typeof m.metalness==='number') m.metalness=Math.min(m.metalness,0.15);
      if(typeof m.roughness==='number') m.roughness=Math.max(m.roughness,0.6);
    }
  });
  ['A','B','C'].forEach(applyParamsToTexture);
  refreshTags();
}

/* ハイライト（薄い赤） */
function setMatHighlight(mat, on){
  if(!mat) return;
  const ud = mat.userData;
  if(!ud._hlSaved){
    ud._hlSaved = true;
    if(mat.emissive){ ud._origEmissive = mat.emissive.clone(); ud._origEmissiveIntensity = (typeof mat.emissiveIntensity==='number') ? mat.emissiveIntensity : undefined; }
    if(mat.color) ud._origColor = mat.color.clone();
  }
  if(on){
    if(mat.emissive){ mat.emissive.setHex(0xff4d4d); if(typeof mat.emissiveIntensity==='number') mat.emissiveIntensity = 1.8; }
    if(mat.color) mat.color.setHex(0xff6b6b);
  }else{
    if(mat.emissive && ud._origEmissive){ mat.emissive.copy(ud._origEmissive); if(typeof mat.emissiveIntensity==='number' && ud._origEmissiveIntensity !== undefined) mat.emissiveIntensity = ud._origEmissiveIntensity; }
    if(mat.color && ud._origColor) mat.color.copy(ud._origColor);
  }
  mat.needsUpdate = true;
}

/* ====== 吹き出し Picker ====== */
const picker = $('picker');
const pickerTitle = $('pickerTitle');
let pickerMat = null;

function updatePickerThumbs(){
  ['A','B','C'].forEach(slot=>{
    const btn = picker.querySelector(`button[data-slot="${slot}"]`);
    const img = btn.querySelector('img');
    const t = state[slot].tex;
    const src = t && t.image && (t.image.currentSrc || t.image.src);
    if(src){ img.src = src; img.style.display='block'; }
    else{ img.removeAttribute('src'); img.style.display='none'; }
  });
}

function showPickerForMat(mat, clientX, clientY, title){
  pickerMat = mat;
  updatePickerThumbs();

  // 一旦表示してサイズ取得→画面内に収める
  picker.style.display = 'block';
  const r = picker.getBoundingClientRect();
  let x = clientX + 10, y = clientY + 10, pad=8;
  if (x + r.width + pad > window.innerWidth)  x = clientX - r.width - 10;
  if (y + r.height + pad > window.innerHeight) y = clientY - r.height - 10;
  picker.style.left = x + 'px';
  picker.style.top  = y + 'px';
  pickerTitle.textContent = title || 'パーツに割り当て';

  // 現在の割り当てハイライト
  picker.querySelectorAll('button[data-slot]').forEach(btn=>{
    btn.classList.toggle('active', assign[mat.uuid] === btn.dataset.slot);
  });

  // ハイライトON
  setMatHighlight(mat, true);
}
function hidePicker(){
  picker.style.display = 'none';
  if (pickerMat) { setMatHighlight(pickerMat, false); pickerMat = null; }
}
// 吹き出しボタン押下
picker.addEventListener('click', (e)=>{
  const b = e.target.closest('button[data-slot]');
  if(!b || !pickerMat) return;
  const slot = b.dataset.slot; // 'A'|'B'|'C'|'—'
  assign[pickerMat.uuid] = slot;
  applyAssignments();
  hidePicker();
  msg(`割り当て: ${slot==='—' ? 'なし' : slot}`);
});
// 外側クリックで閉じる
document.addEventListener('pointerdown', (e)=>{
  if(picker.style.display!=='none' && !picker.contains(e.target)) hidePicker();
});

/* ====== Raycaster で 3D パーツをクリック ====== */
const ray = new THREE.Raycaster(); const pt = new THREE.Vector2();
canvas.addEventListener('pointerdown',(e)=>{
  // ← 重要：外側クローズの pointerdown が走らないように止める
  e.stopPropagation();

  const rect=canvas.getBoundingClientRect();
  pt.x=((e.clientX-rect.left)/rect.width)*2-1; pt.y=-((e.clientY-rect.top)/rect.height)*2+1;
  ray.setFromCamera(pt,camera);
  const root = model || scene;
  const hit = ray.intersectObject(root,true)[0];
  if(!hit || !hit.object){ hidePicker(); return; }

  // 対象マテリアル
  let mat = hit.object.material;
  if(Array.isArray(mat)) mat = mat[ hit.face && typeof hit.face.materialIndex==='number' ? hit.face.materialIndex : 0 ];
  if(!mat){ hidePicker(); return; }

  const title = `${niceName(mat.name)} — ${mat.name||''}`;
  showPickerForMat(mat, e.clientX, e.clientY, title);
});

/* ====== パーツリスト（クリックで吹き出し） ====== */
function buildMatList(){
  const box = $('matList'); if(!box) return;
  box.innerHTML='';
  targetMats.forEach(m=>{
    if(!(m.uuid in assign)){
      const n = (m.name||'').toLowerCase();
      if(n.startsWith('fabric_a') || n.includes('_a_')) assign[m.uuid] = 'A';
      else if(n.startsWith('fabric_b') || n.includes('_b_')) assign[m.uuid] = 'B';
      else if(n.startsWith('fabric_c') || n.includes('_c_')) assign[m.uuid] = 'C';
      else assign[m.uuid] = '—';
    }
    const row=document.createElement('div'); row._mat = m;
    const name=document.createElement('span'); name.className='name'; name.textContent = `${niceName(m.name)} ${m.name ? '— '+m.name : ''}`;
    const tag=document.createElement('span'); tag.className='tag'; tag.textContent = assign[m.uuid] || '—';

    row.addEventListener('click', (ev)=>{
      ev.stopPropagation();                   // ← 重要：即クローズを防止
      const r = row.getBoundingClientRect();
      showPickerForMat(m, r.right, r.top + r.height/2, `${niceName(m.name)} — ${m.name||''}`);
    });
    row.addEventListener('pointerenter', ()=> setMatHighlight(m, true));
    row.addEventListener('pointerleave', ()=> { if(pickerMat!==m) setMatHighlight(m, false); });

    row.appendChild(name); row.appendChild(tag); box.appendChild(row);
  });
}
function refreshTags(){
  [...document.querySelectorAll('#matList > div')].forEach(row=>{
    if(!row._mat) return;
    const tag = row.querySelector('.tag');
    if(tag) tag.textContent = assign[row._mat.uuid] || '—';
  });
}

/* UI: カメラ / ファイル読込 */
$('resetCam').addEventListener('click', ()=>{
  if(model) fit(model);
  else { camera.position.set(0,1.2,3); controls.target.set(0,0,0); controls.update(); }
});
$('texA').addEventListener('change', e=>{
  const f=e.target.files&&e.target.files[0]; if(!f) return;
  state.A.tex = texLoader.load(URL.createObjectURL(f), ()=>{ prepTexture(state.A.tex); applyParamsToTexture('A'); applyAssignments(); msg('生地Aを読み込みました'); });
});
$('texB').addEventListener('change', e=>{
  const f=e.target.files&&e.target.files[0]; if(!f) return;
  state.B.tex = texLoader.load(URL.createObjectURL(f), ()=>{ prepTexture(state.B.tex); applyParamsToTexture('B'); applyAssignments(); msg('生地Bを読み込みました'); });
});
$('texC').addEventListener('change', e=>{
  const f=e.target.files&&e.target.files[0]; if(!f) return;
  state.C.tex = texLoader.load(URL.createObjectURL(f), ()=>{ prepTexture(state.C.tex); applyParamsToTexture('C'); applyAssignments(); msg('生地Cを読み込みました'); });
});

/* クリアA/B/C（画像のみ外す） */
function clearTexture(key){
  const s = state[key]; s.tex = null; s.fileEl.value = ''; applyAssignments(); msg(`生地${key}をクリアしました`);
}
$('clearA').addEventListener('click', ()=>clearTexture('A'));
$('clearB').addEventListener('click', ()=>clearTexture('B'));
$('clearC').addEventListener('click', ()=>clearTexture('C'));

/* スライダー（A/B/C） */
state.A.repEl.addEventListener('input', ()=>{ state.A.repeat = Number(state.A.repEl.value); applyParamsToTexture('A'); });
state.A.rotEl.addEventListener('input', ()=>{ state.A.rotDeg = Number(state.A.rotEl.value); applyParamsToTexture('A'); });
state.B.repEl.addEventListener('input', ()=>{ state.B.repeat = Number(state.B.repEl.value); applyParamsToTexture('B'); });
state.B.rotEl.addEventListener('input', ()=>{ state.B.rotDeg = Number(state.B.rotEl.value); applyParamsToTexture('B'); });
state.C.repEl.addEventListener('input', ()=>{ state.C.repeat = Number(state.C.repEl.value); applyParamsToTexture('C'); });
state.C.rotEl.addEventListener('input', ()=>{ state.C.rotDeg = Number(state.C.rotEl.value); applyParamsToTexture('C'); });

/* 表示リセット（画像は残す） */
$('resetAll').addEventListener('click', ()=>{
  hidePicker();
  Object.keys(assign).forEach(k=>assign[k]='—');
  ['A','B','C'].forEach(key=>{
    const s = state[key]; s.repeat = 3; s.rotDeg = 0; s.repEl.value = 3; s.rotEl.value = 0; s.repv.textContent = '3'; s.rotv.textContent = '0';
  });
  targetMats.forEach(m=>{ if(m){ m.map = null; if(m.color) m.color.set(0xffffff); m.needsUpdate = true; } });
  buildMatList();
  msg('表示を初期化しました（白・倍率3・回転0・割り当てなし）');
});

/* パネル開閉（保存つき） */
const uiWrap = $('uiWrap'), uiToggle = $('uiToggle');
function setCollapsed(v){ uiWrap.classList.toggle('collapsed', v); uiToggle.textContent = v ? '›' : '‹'; localStorage.setItem('uiCollapsed', v ? '1' : '0'); }
uiToggle.addEventListener('click', ()=> setCollapsed(!uiWrap.classList.contains('collapsed')));
setCollapsed(localStorage.getItem('uiCollapsed')==='1');

/* ループ */
function resize(){ const w=canvas.clientWidth, h=canvas.clientHeight;
  if(canvas.width!==w||canvas.height!==h){ renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); } }
function loop(){ resize(); controls.update(); renderer.render(scene,camera); requestAnimationFrame(loop); } loop();

/* メッセージ */
let t; function msg(s){ const el=$('msg'); el.textContent=s; el.hidden=false; clearTimeout(t); t=setTimeout(()=>el.hidden=true,2500); }
</script>
</body></html>
