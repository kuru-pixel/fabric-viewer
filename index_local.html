<!doctype html><html><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fabric Viewer (Local libs)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;font-family:system-ui}
  #ui{position:fixed;z-index:2;top:10px;left:10px;background:#0b0b0bcc;color:#fff;padding:12px;border-radius:10px}
  #ui label{display:block;font-size:12px;margin:6px 0 4px} #ui input[type="range"]{width:220px}
  #msg{position:fixed;z-index:2;bottom:10px;left:50%;transform:translateX(-50%);background:#0009;color:#fff;padding:6px 10px;border-radius:8px;font-size:12px}
  #footer{position:fixed;right:10px;bottom:10px;z-index:2;font-size:12px;background:#0b0b0bcc;color:#fff;padding:6px 10px;border-radius:8px}
  canvas#c{position:fixed;inset:0;width:100vw;height:100vh;display:block}
</style>
</head><body>
<div id="ui">
  <div style="font-weight:600;margin-bottom:6px">Fabric Viewer</div>
  <label>生地画像アップ（JPG/PNG）<input id="file" type="file" accept="image/*"></label>
  <label>タイル倍率 <input id="repeat" type="range" min="1" max="12" step="0.5" value="3"> <span id="repv">3</span></label>
  <label>回転（度） <input id="rot" type="range" min="0" max="180" step="1" value="0"> <span id="rotv">0</span></label>
  <button id="resetCam">カメラリセット</button> <small id="matinfo"></small>
  <div style="margin-top:6px;"><small>※ `assets/garment.glb` が無い間はキューブ表示</small></div>
</div>
<div id="footer">ドラッグで回転 / ホイールでズーム / 右ドラッグで移動</div>
<div id="msg" hidden></div>
<canvas id="c"></canvas>

<!-- ローカル同梱ライブラリ -->
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.js"></script>
  
<script>
const SHOULD_APPLY_TO_ALL = true;
const GLB_PATH = './assets/garment.glb';

const canvas = document.querySelector('#c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
if (renderer.outputColorSpace !== undefined) renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x141414);
const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 100); camera.position.set(0,1.6,3.2);
const controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true;
scene.add(new THREE.HemisphereLight(0xffffff,0x223,1.0));
const dir = new THREE.DirectionalLight(0xffffff,1.0); dir.position.set(2,2,4); scene.add(dir);

let model, targetMats=[];
const loader = new THREE.GLTFLoader();
loader.load(GLB_PATH, (glb)=>{ model=glb.scene; scene.add(model); analyze(model); fit(model); msg('garment.glb を読み込みました'); },
  undefined, ()=>{ const g=new THREE.BoxGeometry(1,1.2,0.5); const m=new THREE.MeshStandardMaterial({color:0x999999,metalness:0.1,roughness:0.7});
  const cube=new THREE.Mesh(g,m); scene.add(cube); targetMats=[cube.material]; updateMatInfo(); msg('assets/garment.glb が無いのでキューブ表示'); });

function analyze(root){
  const mats=new Set();
  root.traverse(o=>{ if(o.isMesh && o.material){ Array.isArray(o.material)?o.material.forEach(m=>mats.add(m)):mats.add(o.material); }});
  targetMats = Array.from(mats).filter(m => (m.name||'').startsWith('fabric_') && m.isMeshStandardMaterial);
  if(!targetMats.length && SHOULD_APPLY_TO_ALL) targetMats = Array.from(mats).filter(m=>m.isMeshStandardMaterial);
  updateMatInfo();
}
function updateMatInfo(){ document.getElementById('matinfo').textContent = `適用対象: ${targetMats.length} material(s)`; }
function fit(obj){
  const box=new THREE.Box3().setFromObject(obj), size=box.getSize(new THREE.Vector3()).length(), center=box.getCenter(new THREE.Vector3());
  controls.target.copy(center); const dist=size*0.6/Math.tan((Math.PI*camera.fov)/360);
  camera.position.copy(center.clone().add(new THREE.Vector3(0,size*0.1,dist))); camera.near=size/100; camera.far=size*10; camera.updateProjectionMatrix(); controls.update();
}

const texLoader = new THREE.TextureLoader();
const rep=document.getElementById('repeat'), rot=document.getElementById('rot'), repv=document.getElementById('repv'), rotv=document.getElementById('rotv');
function applyTexture(url){
  const t=texLoader.load(url, ()=>{ if(t.colorSpace!==undefined)t.colorSpace=THREE.SRGBColorSpace; t.wrapS=t.wrapT=THREE.RepeatWrapping; t.anisotropy=renderer.capabilities.getMaxAnisotropy(); tile(); msg('生地テクスチャを適用しました'); });
  targetMats.forEach(m=>{ if(m.isMeshStandardMaterial){ m.map=t; m.needsUpdate=true; if(typeof m.metalness==='number')m.metalness=Math.min(m.metalness,0.15); if(typeof m.roughness==='number')m.roughness=Math.max(m.roughness,0.6);} });
}
function tile(){ repv.textContent=rep.value; rotv.textContent=rot.value;
  targetMats.forEach(m=>{ if(m.map){ m.map.repeat.set(parseFloat(rep.value),parseFloat(rep.value)); m.map.rotation=parseFloat(rot.value)*Math.PI/180; m.map.center.set(0.5,0.5); m.map.needsUpdate=true; }});
}
document.getElementById('file').addEventListener('change', e=>{ const f=e.target.files&&e.target.files[0]; if(!f) return; applyTexture(URL.createObjectURL(f)); });
rep.addEventListener('input', tile); rot.addEventListener('input', tile);
document.getElementById('resetCam').addEventListener('click', ()=>{ if(model)fit(model); else { camera.position.set(0,1.2,3); controls.target.set(0,0,0); controls.update(); } });

function resize(){ const w=canvas.clientWidth, h=canvas.clientHeight; if(canvas.width!==w||canvas.height!==h){ renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); } }
function loop(){ resize(); controls.update(); renderer.render(scene,camera); requestAnimationFrame(loop); } loop();
let t; function msg(s){ const el=document.getElementById('msg'); el.textContent=s; el.hidden=false; clearTimeout(t); t=setTimeout(()=>el.hidden=true,2500); }
</script>
</body></html>
